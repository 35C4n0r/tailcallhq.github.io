---
title: N+1 Problem
description: Discover how to efficiently address the N+1 problem in application development with our comprehensive guide. Learn to reduce server requests and optimize performance using practical solutions and step-by-step examples with the TailCall CLI for GraphQL applications. Enhance your coding practices and ensure scalable, high-performance web applications by mastering techniques to mitigate the N+1 problem, reduce server load, and improve response times.
---

The **N+1 problem** significantly impacts application performance by triggering numerous upstream requests in response to a single downstream request. Let's explore this issue and potential solutions using an example.

## Example

Imagine we need to fetch data from the [jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com/), requiring both posts and their authors' details.

### Fetching Posts

First, we request all posts:

```bash
‚ùØ curl https://jsonplaceholder.typicode.com/posts
  [
    {
      "userId": 1,
      "id": 1,
      "title": "Creating Solutions for Challenges",
      "body": "We anticipate and understand challenges, creating solutions while considering exceptions and criticisms."
    },
    {
      "userId": 1,
      "id": 2,
      "title": "Understanding Identity",
      "body": "Life's essence, measured through time, presents pains and joys. We find solace in the mundane, seeking meaning beyond the visible."
    }
  ]
```

This command retrieves posts from the API, with each post containing a `userId` field indicating its author.

### Fetching Authors

Next, we fetch details for each post's author, such as:

```bash
‚ùØ curl https://jsonplaceholder.typicode.com/users/1
  {
    "id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "Sincere@april.biz",
    "address": {
      "street": "Kulas Light",
      "suite": "Apt. 556",
      "city": "Gwenborough",
      "zipcode": "92998-3874",
      "geo": {
        "lat": "-37.3159",
        "lng": "81.1496"
      }
    },
    "phone": "1-770-736-8031 x56442",
    "website": "hildegard.org",
    "company": {
      "name": "Romaguera-Crona",
      "catchPhrase": "Multi-layered client-server neural-net",
      "bs": "harness real-time e-markets"
    }
  }
```

For 100 posts, this results in 100 additional requests for author details, totaling 101 requests. This is the infamous _N + 1 problem_:

- 1 request for `/posts`
- 100 or `N` requests for `/users/:id` for each user

:::info
This issue can escalate in real-world scenarios, leading to straining resources, increasing server costs, slowing response times, and potentially causing server downtime even at a moderate scale.
:::

Addressing the N+1 problem during application design and development is crucial for efficient API usage. We will examine solutions to mitigate this problem using Tailcall.

## Initial Configuration

Before diving into solutions, let's observe the N+1 problem in the following configuration:

```graphql
schema
  @server(port: 8000)
  @upstream(
    baseURL: "http://jsonplaceholder.typicode.com"
  ) {
  query: Query
}

type Query {
  posts: [Post] @http(path: "/posts")
}

type Post {
  id: Int!
  userId: Int!
  title: String!
  body: String!
  user: User @http(path: "/users/{{.value.userId}}")
}

type User {
  id: Int!
  name: String!
  username: String!
  email: String!
}
```

This configuration sets up a GraphQL schema for a Tailcall server operating on port `8000`, utilizing [jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com/) as its data source. It allows direct querying of posts and, for each post, retrieves the associated author information. Similar to our curl requests above, when we query for posts and their authors we end up issuing multiple user calls upstream:

Let's examine the CLI output for this configuration with Tailcall's `start` command:

```text {6-9}
‚ùØ tailcall start ./examples/jsonplaceholder.graphql
  INFO File read: ./examples/jsonplaceholder.graphql ... ok
  INFO N + 1 detected: 1
  INFO üöÄ Tailcall launched at [0.0.0.0:8000] over HTTP/1.1
  INFO üåç Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql
  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1
  INFO GET http://jsonplaceholder.typicode.com/users/8 HTTP/1.1
  ...
  INFO GET http://jsonplaceholder.typicode.com/users/10 HTTP/1.1
```

Tailcall logs a sequence of requests made to fetch posts and then individual users, highlighting the N+1 problem in real-time. Even though there are 100 posts, only 10 requests are made to fetch the authors. This happens because Tailcall automatically deduplicates all upstream requests. However, it still issues 10 requests, which is not bad but we can do better.

:::tip
Tailcall can look into your configuration and identify optimizations such as deduplications automatically. You can disable this behavior with the [dedupe](../directives/upstream.md#dedupe) setting.
:::

## Reviewing the logs

Before we get into batching, if you observe closely the above logs Tailcall identified that there was one N + 1 issue, even before the requests were made:

```text {3}
‚ùØ tailcall start ./examples/jsonplaceholder.graphql
  INFO File read: ./examples/jsonplaceholder.graphql ... ok
  INFO N + 1 detected: 1
  INFO üöÄ Tailcall launched at [0.0.0.0:8000] over HTTP/1.1
  INFO üåç Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql
  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1
  INFO GET http://jsonplaceholder.typicode.com/users/8 HTTP/1.1
  ...
  INFO GET http://jsonplaceholder.typicode.com/users/10 HTTP/1.1
```

To get a deeper understanding of what this N + 1 issue is, we can use the `--n-plus-one-queries` parameter with the `check` command:

```text {4,5}
‚ùØ tailcall check ./jsonplaceholder.graphql --n-plus-one-queries
  INFO File read: ./examples/jsonplaceholder.graphql ... ok
  INFO Config ./examples/jsonplaceholder.graphql ... ok
  INFO N + 1 detected: 1
  query { posts { user } }
```

Incredible, isn't it? Tailcall has discovered that querying for posts followed by their users results in N + 1 upstream calls. This represents a significant productivity gain, as you can now identify all such N + 1 issues upfront without resorting to complex profiling, tracing, or other runtime techniques. The `check` command identifies the minimal query that could lead to an N + 1 problem by performing semantic analysis of your configuration.

## Optimized Configuration

An effective technique to mitigate the N+1 problem is batching similar requests, significantly reducing the number of server calls. The TailCall CLI provides this capability for addressing the N+1 issue in GraphQL.

To utilize this feature, edit the `@http` directive on `Post.user` in your GraphQL schema as follows:

```graphql {9-10}
type Post {
  id: Int!
  userId: Int!
  title: String!
  body: String!
  user: User
    @http(
      path: "/users"
      query: [{key: "id", value: "{{value.userId}}"}]
      batchKey: ["id"]
    )
}
```

The described changes introduce two significant tweaks to the `@http` directive:

1. **Addition of a query parameter:**

   ```graphql {6}
   type Post {
     # ...
     user: User
       @http(
         path: "/users"
         query: [{key: "id", value: "{{value.userId}}"}]
         batchKey: ["id"]
       )
   }
   ```

   This configuration generates a URL aligning the user ID with the `userId` from the parent `Post`. For a batch of posts, the CLI compiles a single URL, such as `/users?id=1&id=2&id=3...id=10`, consolidating the requests into one.

1. **Addition of a batchKey:**
   ```graphql {7}
   type Post {
     # ...
     user: User
       @http(
         path: "/users"
         query: [{key: "id", value: "{{value.userId}}"}]
         batchKey: ["id"]
       )
   }
   ```
   This parameter instructs the system to convert the list of responses into a map using the user's `id` as the unique key, allowing differentiation of each user value in the response list.

Using this approach, you can reduce the number of requests from 11 (for 10 users, plus one initial request for the post) down to 2. This small change effectively addresses the N+1 problem. Let's see what the server logs when you now start with this updated configuration:

```graphql {21-22}
schema
  @server(port: 8000)
  @upstream(
    baseURL: "http://jsonplaceholder.typicode.com"
  ) {
  query: Query
}

type Query {
  posts: [Post] @http(path: "/posts")
}

type Post {
  id: Int!
  userId: Int!
  title: String!
  body: String!
  user: User
    @http(
      path: "/users"
      query: [{key: "id", value: "{{value.userId}}"}]
      batchKey: ["id"]
    )
}

type User {
  id: Int!
  name: String!
  username: String!
  email: String!
}
```

```text {3}
‚ùØ tailcall start ./examples/jsonplaceholder.graphql
  INFO File read: ./examples/jsonplaceholder.graphql ... ok
  INFO N + 1 detected: 0
  INFO üöÄ Tailcall launched at [0.0.0.0:8000] over HTTP/1.1
  INFO üåç Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql
  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1
  INFO GET http://jsonplaceholder.typicode.com/users?id=1&id=10&id=2&id=3&id=4&id=5&id=6&id=7&id=8&id=9 HTTP/1.1
```

## Conclusion

The logs clearly demonstrate a substantial reduction in requests. Initially, fetching 100 posts resulted in an additional 100 requests for author details, totaling 101 requests. However, after deduping and applying TailCall optimization with batching using the `batchKey`, we observed that only two requests were made. TailCall intelligently merged upstream requests and utilized the batch API configured by the user.

This optimization significantly contrasts with the initial approach by reducing the number of server requests, thereby minimizing server load, enhancing response times, and potentially lowering server costs. It underscores the effectiveness of Tailcall in addressing the N+1 problem through thoughtful schema design and the use of advanced semantic analysis techniques.
